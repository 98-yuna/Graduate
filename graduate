% --------[ 5개의 변조 유형(연속신호 디지털 변조)을 categorial형 배열(1X5)로 생성 ]--------
 modulationTypes = categorical(["BPSK", "QPSK", "8PSK","16QAM", "64QAM"]); 

% ------[ 학습데이터 생성하기(1000개 생성하여 800개는 훈련셋, 100개는 검증셋, 100개는 테스트셋) ]------

numFramesPerModType = 1000;
percentTrainingSamples = 80;
percentValidationSamples = 10;
percentTestSamples = 10;

% frame > sample > symbol
sps = 8; % Symbol per sample 1 sample = 8bits(symbols)    
spf = 1024; % Sample per frame 1 frame = 1024 samples     

signal = sps*spf; % 한 개의 신호를 생성하기 위해서는, 8192 bit필요함

% 샘플링레이트가 원래신호의 최고 주파수의 2배 이상이면 원래 신호를 복원가능
fs = 200e3;  % 샘플링 레이트 = 200kHz
fc = 900e6;  % 중심주파수 = 900MHz


% -------------[ 생성한 입력신호가 지나갈 채널을 만들기]------------
% Rician fading 모델은 많은 장애물이 존재하면서 송/수신기 사이에 LoS신호가 있는 환경에 주로 적용
% 페이딩 = 단시간 내에서 일어나는 전하의 감쇠로 여러가지 요인에 의해 발생
% 다중 경로 페이딩 = 여러가지 요인에 의해 전파의 경로가 여러 경로로 흩어지는 것
% 다중 경로로 인해 지연 확산이 발생하며, 신호 왜곡이 발생된다. 
% 도플러 효과 = 이동국의 움직임으로 인해 전파의 중심 주파수가 천이하는 것 같은 효과 
% comm.RicianChannel = 다중 경로 Rician 페이딩 채널을 통해 입력 신호를 필터링한다.
% comm.RicianChannel('입력 신호 샘플 속도', 200kHz, '신호 대 잡음비', 30,
%                           '이산 경로 지연', [0 1.8 3.4] / 200e3, '이산 경로의 평균 이득', [0 -2 -10], 'Racian k 계수', 4
%                           '모든 채널 경로에 대한 최대 도플러 이동', 4 , '최대 클록오프셋', 5ppm, '중심주파수', 900MHz)
% 이산 경로 지연에 따른 평균 경로이득은 사용자가 임의로 지정해도 괜찮음
% 이산 경로 지연을 [0 1.8 3.4]로 가정하고 이에 대응하는 평균 경로 이득을 [0 -2 -10dB]로 가정 
channel = helperModClassTestChannel('SampleRate',fs, 'SNR',30, 'PathDelays',[0 1.8 3.4] / 200e3, ...
  'AveragePathGains',[0 -2 -10], 'KFactor',4, 'MaximumDopplerShift',4,  'MaximumClockOffset',5, ...
  'CenterFrequency',fc)


% --------------------[파형 생성]-----------------------
% 각 변조 유형에 대해 프레임을 생성(1000)
% 난수 생성기를 재생성 할 수 있도록 알려진 상태로 설정
% 시뮬레이션이 실행될때마다 동일한 프레임
rng(1235)
tic

 transDelay = 50
% f = fullfile(폴더명, 파일이름) = 지정된 폴더 및 파일 이름만들기 
% ex) f = fullfile('myfolder', 'mysubfolder', 'myfile.m') 인 경우
%     f = 'myfolder/mysubfolder/myfile.m
% tmp/ModClassDataFiles 생성
dataDirectory = fullfile(tempdir,"ModClassDataFiles");
% "C:\Users\USER\AppData\Local\Temp\ModClassDataFiles" 들어가면 신호파일 확인가능


fileNameRoot = "signal";
numModulationTypes = length(modulationTypes); % = 5

% 입력신호파일이 존재하는가?
dataFilesExist = false; 
% 파일이 존재하는 경우
if exist(dataDirectory,'dir')
    % 폴더에 signal로 시작하는 파일 모두 나열
  files = ls(fullfile(dataDirectory,sprintf("%s*",fileNameRoot)));
    % 나열한 갯수와 5*1000(=5000)가 일치하면
  if length(files) == numModulationTypes*numFramesPerModType
    % 파일이 존재한다는 뜻, dataFilesExist변수의 상태를 false -> true로 변경
    dataFilesExist = true;
  end
end

% 파일이 존재하지 않는경우
if ~dataFilesExist
    % disp(x) = x를 그대로 출력 
    %         => Generating data and saving in data files... 문구를 출력한 후에
  disp("Generating data and saving in data files...")
  % [status, msg, msgID] = mkdir() 발생하는 모든 경고 또는 오류 메세제 id 반환
  % => 폴더(tmp/ModClassDataFiles)를 만들기
  [success,msg,msgID] = mkdir(dataDirectory);
  % 만약, 폴더 생성에 실패한 경우, 왜 오류가 발생했는지 메세지를 출력한다.
  if ~success
    error(msgID,msg)
  end
  
  % modType = 1:5까지 반복문을 돌려 입력신호에 넣을 파형을 생성한다. 
  for modType = 1:numModulationTypes
    fprintf('%s - Generating %s frames\n', ...
      datestr(toc/86400,'HH:MM:SS'), modulationTypes(modType))
    
    label = modulationTypes(modType);
    numSymbols = (numFramesPerModType / sps);
    dataSrc = helperModClassGetSource(modulationTypes(modType), sps, 2*spf, fs);
    modulator = helperModClassGetModulator(modulationTypes(modType), sps, fs);
    if contains(char(modulationTypes(modType)), {'B-FM','DSB-AM','SSB-AM'})
      % Analog modulation types use a center frequency of 100 MHz
      channel.CenterFrequency = 100e6;
    else
      % Digital modulation types use a center frequency of 902 MHz
      channel.CenterFrequency = 902e6;
    end
    
    for p=1:numFramesPerModType
      % Generate random data
      x = dataSrc();
      
      % Modulate
      y = modulator(x);
      
      % Pass through independent channels
      rxSamples = channel(y);
      
      % Remove transients from the beginning, trim to size, and normalize
      frame = helperModClassFrameGenerator(rxSamples, spf, spf, transDelay, sps);
      
      % Save data file
      fileName = fullfile(dataDirectory,...
        sprintf("%s%s%03d",fileNameRoot,modulationTypes(modType),p));
      save(fileName,"frame","label")
    end
  end
else
  disp("Data files exist. Skip data generation.")
end



% --------- [ CNN(합성곱) 신경망 학습알고리즘(?) 만들기]------------
  % Fully Connected Layer(완전 연결 계층)만으로 구성된 인공 신경망의 입력 데이터 = 1차원 배열 
  % 한장의 사진은 3차원 데이터, 배치모드에 사용되는 여러장의 사진은 4차원 데이터 
  % 사진데이터를 평면화시키는 과정에서 공간정보가 손실됨
  % 이미지의 공간 정보를 유지한 상태로 학습이 가능한 모델 = CNN
  
  % Conv-ReLU-(Pooling)흐름으로 연결
  % CNN = 이미지 특징을 추출하는 부분 + 분류하는 부분
  % 이미지 특징 추출 = Convolution Layer와 Pooling Layer를 여러 겹 쌓음
  % CNN 마지막 부분에는 이미지 분류를 위한 Fully Connected Layer 추가 -> 1차원 배열로
  % 활성화 함수로는 Softmax를 주로 사용
 
  
  % 과적합 문제를 해결하기 위해
  % 과적합 = 신경망이 훈련 데이터에만 지나치게 적응되어 그 외의 데이터에는 제대로 대응하지 못함
  % 과적합 발생 이유 = 매개변수가 많고 표현력이 높은 경우, 훈련데이터가 적은 경우
  
  % 드롭아웃 = 훈련 중 은닉층의 뉴런을 무작위로 골라 삭제 -> 신호가 전달 X
  %            훈련 중에는 데이터를 흘릴 때마다 삭제할 뉴런을 무작위로 선택함
  %            시험 때는 모든 뉴런에 신호를 전달함
  % 드롭아웃을 적용시키면 훨씬 성능이 개선됨
   dropoutRate = 0.5;
   
  % numel(배열) 배열 요소의 개수 
  numModTypes = numel(modulationTypes); % numModTypes(변조신호갯수) = 5
  % netWidth = 네트워크 너비, 네트워크의 첫번째 단계에 있는 컨볼루션 계층의 필터 갯수 
  netWidth = 1;
  filterSize = [1 8];
  poolSize = [1 2];
  modClassNet = [ 
  % imageInputLayer = 입력계층
  % ([크기] : 2x1024, 데이터 정규화 : x, 데이터 증대 변환 : x, 정규화 차원 : auto, 이름 : Input Layer)
  imageInputLayer([2 1024 1], 'Normalization', 'none', 'Name', 'Input Layer')
  % convolution2dLayer : 2차원 컨벌루션 계층, 입력값에 슬라이딩 컨벌루션 필터를 적용.
  %                      입력값의 세로와 가로 방향을 따라 필터를 이동하면서 가중치와 입력값의 내적을 계산한 다음 
  %                      편향 값을 추가하여 입력값을 컨벌루션 한다.
  
  % batchNormalizationLayer : 배치 정규화 계층, 컨볼루션 신경망의 훈련 속도를 높이고 
  %                           신경망 초기화에 대한 민감도를 줄이려면 컨볼루션 계층과 비선형계층(ex:ReLu)
  %                           사이에 배치 정규화 계층을 추가해야 한다. 
  
  % reluLayer : RELU 계층, 입력값의 각 요소에 대해 0보다 작은 값은 모두 0으로 설정한다.
 
  % maxPooling2dLayer : 최대값 폴링 계층, 입력값을 직사각형 풀링 영역으로 나누고 각 영역의 최대값을 계산하여
  %                     다운 샘플링을 수행, 크기를 줄여 계산량을 줄이고 과적합을 방지한다.

  % averagePolling2Lyaer : 평균값 폴링 계층, 입력값을 직사각형 폴링 영역으로 나누고 각 영역의 평균값을 계산하여
  %                        다운 샘플링을 수행, 크기를 줄여 계산량을 줄이고 과적합을 방지한다.
  
  
  % 5개의 컨볼루션 계층, 배치정규화 계층, ReLU 활성화함수, 최댓값 풀링계층
  % 크기가 [1 8]인 필터 16개(16*1)개를 가지며 계층 입력값의 모든 가장자리에 패딩을 추가하는 2차원 컨볼루션 계층
  % Padding = same, 입력값을 세로와 가로 방향으로 순회하는 스텝 크기 Stride = [1 1]
  %  => 출력 크기가 입력크기와 같아지도록 채우기 크기가 훈련시점에계산
  convolution2dLayer(filterSize, 16*netWidth, 'Padding', 'same', 'Name', 'CNN1')
  % 이름이 'BN1'인 배치 정규화 계층
  batchNormalizationLayer('Name', 'BN1')
  % 이름이 'ReLU1'인 relu계층
  reluLayer('Name', 'ReLU1')
  % 이름이 'MaxPool1'이고 풀 크기가 [1 2], Stride가 [1 2]인 최대값 폴링계층 
  maxPooling2dLayer(poolSize, 'Stride', [1 2], 'Name', 'MaxPool1')
  
  convolution2dLayer(filterSize, 24*netWidth, 'Padding', 'same', 'Name', 'CNN2')
  batchNormalizationLayer('Name', 'BN2')
  reluLayer('Name', 'ReLU2')
  maxPooling2dLayer(poolSize, 'Stride', [1 2], 'Name', 'MaxPool2')
  
  convolution2dLayer(filterSize, 32*netWidth, 'Padding', 'same', 'Name', 'CNN3')
  batchNormalizationLayer('Name', 'BN3')
  reluLayer('Name', 'ReLU3')
  maxPooling2dLayer(poolSize, 'Stride', [1 2], 'Name', 'MaxPool3')
  
  convolution2dLayer(filterSize, 48*netWidth, 'Padding', 'same', 'Name', 'CNN4')
  batchNormalizationLayer('Name', 'BN4')
  reluLayer('Name', 'ReLU4')
  maxPooling2dLayer(poolSize, 'Stride', [1 2], 'Name', 'MaxPool4')
  
  convolution2dLayer(filterSize, 64*netWidth, 'Padding', 'same', 'Name', 'CNN5')
  batchNormalizationLayer('Name', 'BN5')
  reluLayer('Name', 'ReLU5')
  maxPooling2dLayer(poolSize, 'Stride', [1 2], 'Name', 'MaxPool5')
  
  % 컨볼루션 계층, 배치정규화 계층, ReLU 활성화함수, 평균값 풀링계층
  convolution2dLayer(filterSize, 96*netWidth, 'Padding', 'same', 'Name', 'CNN6')
  batchNormalizationLayer('Name', 'BN6')
  reluLayer('Name', 'ReLU6')
  averagePooling2dLayer([1 32], 'Name', 'AP1')
  
  % 완전 연결계층, softmax 활성화함수, 5개 클래스(?)로 분류하기 위해 첫번째 매개변수 5
  fullyConnectedLayer(numModTypes, 'Name', 'FC1')
  softmaxLayer('Name', 'SoftMax')
  
  classificationLayer('Name', 'Output') ]
